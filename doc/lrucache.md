#### description
&emsp;常用的三种缓存淘汰算法：`FIFO`,`LFU`,`LRU`

#### 0x01 FIFO(First In First Out)
&emsp;先进先出，淘汰缓存中最早添加的记录。FIFO认为，最早添加的记录，其不被使用的可能性更大。 这种算法实现方式：创建一个队列，新增加的记录放到队列尾部，每次内存不够的时候，淘汰队列首部。这种算法会频繁的添加缓存，又被淘汰出去，导致缓存命中率低下。
&emsp;单纯的队列，新增加放到队列尾部，淘汰掉队列的首部(或者新增加的放到队列的头部，淘汰掉队列的尾部)


#### 0x02 LFU(Least Frequently Used)
&emsp;最少使用，也就说淘汰缓存中访问频率最低的记录。LFU算法认为，如果数据过去访问多次，那么将来访问的频率也更高。LFU的实现需要维护一个按照访问次数排序的队列，每次访问，则访问的次数增加1， 队列重新排序，淘汰时候选择访问次数最少即可。LFU的算法命中率是比较高的。但是缺点比较明显，维护每个记录的访问次数，对内存消耗比较高。另外如果数据访问模式发生变化，则需要更长的时间去适应，也就说说LFU算法受历史数据影响比较大。例如某个数据的历史访问奇高，但是在某个时间段后几乎不再被访问，但是因为历史访问次数过高，则迟迟不会被淘汰。
&emsp;实现类似维护一个字典(key:count),具体实现可以用最小堆来实现，淘汰最小的

#### 0x03 LRU(Last Recently Used)
&emsp;最近最少使用，相对易仅仅考虑时间因素的FIFO和仅仅考虑访问频率的LFU，LRU算法可以被认为是相对平衡的一种淘汰算法，如果数据最近被访问过，那么将来被访问的概率也高。LRU算法的实现也简单，维护一个队列，如果某条记录被访问了，则移动到队列尾部，那么对首是最近最少访问的数据，淘汰该记录即可。
&emsp;通过移动链表。
